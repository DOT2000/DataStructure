/**
 *  @author 小粥无敌辣
 *  2023/9/18 16:32
 *  DataStructures
 */

/**
 * 需要注意的是，这种方式的代码结构较复杂，可读性较差。
 * 在实际应用中，建议仅在递归导致栈溢出的情况下才使用非递归版本。
 * 在一般情况下，递归算法更易于理解和实现，更具可读性。
 */

/**
 * 函数解读：
 * 递归程序利用栈数据结构实现非递归转化，说白了就是模拟递归工作栈的使用过程。
 * 因为递归工作栈每次压栈的信息最主要的就是： 实参  返回地址
 * 那么我们就要利用循环和条件判断，恰当的把后处理的实参值压栈，待出栈信号到来，依次出栈
 *
 * 因为系统每次在更新了执行方法后，正在被操作和判断的值就发生了变化，
 * 我们要把最先需要判断的值一步步地接近递归结束条件，把在此之后再进行判断的值先压入栈中。
 *
 * 更通俗的讲：
 * 采用栈模拟递归过程中子任务的产生和处理过程:
 *           1. 产生新的子任务对应入栈操作;
 *           2. 处理子任务对应出栈操作;
 *           3. 未来先处理的子任务后入栈;
 *           4. 未来后处理的子任务先入栈。
 *
 * @param num
 * @return factorial
 */
int Factorial(int num){
    if(num == 0 || num == 1){
        return 1;
    }
    int factorial = 1;
    int stack[num - 1];
    int index = -1;
    stack[++index] = num;
    num--;
    while(index >= 0){
        if(num == 0 || num == 1){
            factorial *= stack[index--];
        }else{
            stack[++index] = num;
            num--;
        }
    }
    return factorial;
}
